<blockquote>
<p><a href="https://www.inflearn.com/course/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EC%9E%85%EB%AC%B8/dashboard">초보를 위한 쿠버네티스 안내서 - 인프런 | 강의</a></p>
</blockquote>
<p>노션에 정리해두었던 자료를 블로그로 옮겨 옵니다.</p>
<p>기분 좋은 강의 수료증도 첨부해 봅니다:)
<img alt="" src="https://velog.velcdn.com/images/jaehere/post/7fa9758b-ee57-4683-bf80-d59f80e3c2ec/image.png" /></p>
<hr />
<h2 id="0-쿠버네티스-시작하기">#0 쿠버네티스 시작하기</h2>
<p>컨테이너 오케스트레이션</p>
<ul>
<li><p>서버 상태관리</p>
<ul>
<li><p>문서화 :  만들어둬도 환경이나 os, 버전이 바뀌면 따라해도 잘 안되는 문제 발생</p>
</li>
<li><p>서버관리도구 : CHEF, ANSIBLE 등 도구가 대신해서 명령어를 날려줌. 설정관리도구도 배워야하고, 서버를 복잡하게 관리 시 도구 자체의 사용법도 난이도가 높아지는 문제 발생</p>
</li>
<li><p>가상머신 : 가상머신 하나 띄우고 프로그램 하나 설치해두면 충돌날 일도 없고, 가상머신 여러개를 묶어서 사용도 가능. 기본적으로 느림. 클라우드 환경에 안맞는 부분 발생. 특정 vendor에 dependency가 생김</p>
</li>
<li><p>docker : 모든 실행환경을 컨테이너로 바꿈. 도커만 설치되어 있으면 어디서든 동작. 사용법 쉬움. vm처럼 느리지 않고, 효율적. 서버 관리자의 복잡함을 해결</p>
<p>→ 오예 도커 등장</p>
</li>
</ul>
</li>
<li><p>도커 컨테이너 특징</p>
<ul>
<li><p>가상머신과 비교하여 컨테이너 생성이 쉽고 효율적</p>
</li>
<li><p>컨테이너 이미지를 이용한 배포와 롤백이 간단</p>
</li>
<li><p>언어, 프레임워크에 상관없이 애플리케이션을 동일한 방식으로 관리</p>
</li>
<li><p>개발, 테스팅,운영 환경은 물론 로컬 pc 와 클라우드까지 동일한 환경을 구축</p>
</li>
<li><p>컨테이너는 오픈소스</p>
</li>
<li><p>특정 클라우드 벤더에 종속적이지 않음</p>
</li>
<li><p>도커이미지만 잘 만들어주면 관리 쉬움</p>
</li>
<li><p>프로그램을 컨테이너화 해서 사용하는 것 :  containerization</p>
</li>
<li><p>Develop → Build → Ship → Run</p>
<p>→ 컨테이너 수백개가 되면 고민이 됨… 도커 좋긴한데 많은 걸 관리하려면 여전히 손 많이 가..</p>
</li>
</ul>
</li>
</ul>
<ul>
<li>도커의 문제<ul>
<li><blockquote>
<p>_ ssh 도커서버 1,2,3에 접속해서 실행하는 관리가 어려운 문제 발생</p>
</blockquote>
</li>
<li>도커를 많이 사용하다보면 빈공간이 생기기 마련.. 어떤 서버가 여유가 있는지 보려면 모니터링해야함.</li>
<li>배포시 하나하나 접속해서 배포, 버전 문제 시 롤아웃/롤백 손이 많이감. 중앙에서 버전 관리를 하고싶다는 욕구가 발생</li>
<li>서비스 검색<ul>
<li>proxy → WEB 을 가리킴 proxy에 Web을 바라봐라 설정.  web이 몇개일 경우, LoadBalancer 사용해서 부하 방지. 너무 많아지는 문제. 마이크로서비스</li>
</ul>
</li>
<li>서비스 이상, 부하 모니터링<ul>
<li>몇개의 컨테이너가 죽는 경우, 몇번 서버가 부하 발생의 경우 자동화가 필요함</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>→ Container Orchestration : 복잡한 컨테이너 환경을 효과적으로 관리하기 위한 도구</p>
<ul>
<li><p>컨테이너 오케스트레이션 역할 - 서버관리자 대신 일 해줌. 역으로 관리하는 일이 필요하기도 함</p>
<ul>
<li>CLUSTER<ul>
<li>중앙제어(master-node)</li>
<li>node를 하나하나 관리하는 것이 아니라 cluster 단위로 추상화하여 관리</li>
<li>master가 cluster를 관리하며 , node끼리 네트워킹</li>
<li>node 처음 설계단계 중요</li>
</ul>
</li>
<li>STATE  상태관리<ul>
<li>직접 조치 하지 않더라도 컨테이너 오케스트레이션이 자동으로 맞춰줌</li>
</ul>
</li>
<li>SCHEDULING 배포관리</li>
<li>ROLLOUT ROLLBACK 배포버전관리</li>
<li>SERVICE DISCOVERY 서비스 등록 및 조회<ul>
<li>web 등록 후 proxy서버는 조회하며 설정변경, 프로세스 재시작</li>
</ul>
</li>
<li>VOLUME 볼륨 스토리지<ul>
<li>node에 각각 필요한 볼륨을 amount 함</li>
</ul>
</li>
</ul>
</li>
<li><p>컨테이너 관리도구 춘추전국시대 ㅋㅋ</p>
<ul>
<li>쿠버네티스가 표준처럼 등장~~</li>
</ul>
</li>
<li><p><strong>쿠버네티스 kubernetes</strong> : 컨테이너를 <strong>쉽고 빠르게 배포/확장</strong> 하고 <strong>관리를 자동화</strong>해주는 오픈소스 플랫폼</p>
<ul>
<li>구글에서 처음 만듬 2015 첫 릴리즈</li>
<li>CLOUD NATIVE로 오픈소스 이관</li>
<li>운영에서 사용가능한 컨테이너 오케스트레이션</li>
<li>Planet Scale 행성스케일 20억개보다만 적으면 사용할 수 있다고 …</li>
<li>다양한 요구사항 만족하는 유연성, Run Anywhere</li>
<li>오픈소스, 커뮤니티 발달, 무한한 확장성, 사실상 표준(De facto)</li>
<li>쿠버네티스 Native Platform : Rancher, Red Hat OpenShift, Tanzu 쿠버네티스 위에 만듬<ul>
<li>도커도 쿠버네티스를 지원</li>
<li>EKS(Amazon), AKS(Azure), GKE(Google) 클라우드 3대장 모두 쿠버네티스를 매니지드 서비스로 제공</li>
</ul>
</li>
</ul>
</li>
<li><p>CNCF</p>
<ul>
<li>CLOUD NATIVE COMPUTING FOUNDATION (리눅스 소속)</li>
<li>클라우드 환경에 적합한 컴퓨팅 기술을 지원</li>
<li>쿠버네티스가 플랫폼적인 역할, 그 위에 소프트웨어 프로그램이 돌아감. ← 컨테이너 오케스트레이션의 사실상 표준 (de facto) Cloud Native의 핵심역할</li>
</ul>
</li>
</ul>
<h2 id="1-쿠버네티스-알아보기">#1 쿠버네티스 알아보기</h2>
<ul>
<li>쿠버네티스 용어</li>
</ul>
<pre><code>| 용어 | 발음 |
| --- | --- |
| master | 마스터 |
| node | 노드(구 minion 미니언) |
| k8s | 쿠버네티스, 케이에잇츠, 케이팔에스 |
| kubectl | 큐브 컨트롤, 큐브 시티엘, 큐브커들 |
| etcd | 엣지디, 잇시디, 이티시디 |
| pod | 팟, 파드, 포드 |
| istio | 이스티오 |
| helm | 헬름, 핾, 햄 |
| knative | 케이 네이티브 |</code></pre><ul>
<li><p>쿠버네티스 소개</p>
<ul>
<li>컨테이너화된 애플리케이션을 자동으로 배포, 스케일링 및 관리</li>
<li>컨테이너를 쉽게 관리하고 연결하기 위한 논리적인 단위로 그룹화</li>
<li>구글에서 15년간 경험을 토대로 최상의 아이디어와 방법들을 결합<ul>
<li>borg→k8s</li>
</ul>
</li>
<li>기여업체: 구글, 아마존, 마이크로소프트, ibm, intel, red hat 선두기업들이 쿠버네티스 하나를 같이 만들고 있음. 노하우 및 업계 최고의 아이디어가 녹아들어 있음</li>
<li><strong>자동화, 논리적인 단위, 노하우</strong></li>
<li>쿠버네티스는 그리스어로 조타수, 조종수 / 줄여서 말할 때 k8s, kube 큐브</li>
<li>CNCF 클라우드 네이티브<ul>
<li>클라우드 이후 , 수많은 리소스를 자유롭게 사용하고 추상적으로 관리</li>
</ul>
</li>
</ul>
</li>
<li><p>쿠버네티스 배포 데모</p>
<ul>
<li><p>AWS 클라우드에 ghost 블로그 배포</p>
<blockquote>
<p>kubectl get node</p>
</blockquote>
<blockquote>
<p>kubectl get namespace</p>
</blockquote>
<blockquote>
<p>kubectl get po -n NAME</p>
</blockquote>
<blockquote>
<p>helm install ghost bitmani/ghost \ </p>
</blockquote>
<p>ghost는 helm이라는 패키지매니저를 이용하여 설치</p>
<p>미리 설정해둔 value대로 node.js와 maria db까지 설치가 됨</p>
<blockquote>
<p>kubectl get po ← 상태확인</p>
</blockquote>
<blockquote>
<p>kubectl describe po/ghost- ← describe로 상세정보 보기 언제 scheduling 등</p>
</blockquote>
</li>
<li><p>컨테이너가 죽어버리면 자동으로 띄워주는 기능 확인</p>
<blockquote>
<p>kubectl delete po/ghost-</p>
</blockquote>
<blockquote>
<p>kubectl get po ← 기존꺼 대신에 다른게 다시 뜸. container ochestration은 상태를 유지하려 하기 때문에 컨테이너가 죽더라도 쿠버네티스가 자동으로 띄워줌.</p>
</blockquote>
</li>
<li><p>ghost 버전 바꾸고 재배포 시</p>
<blockquote>
<p>helm upgrade ghost bitnami/ghost \</p>
</blockquote>
<p>그래도 서버가 죽지 않고 살아있음. 아까 생성했던건 그대로 러닝, 새로운 pod이 뜸 . 새로운 pod이 잘 뜨면, 기존의 것을 알아서 죽임.</p>
</li>
<li><p>모니터링</p>
</li>
</ul>
</li>
<li><p>쿠버네티스 아키텍처 (구성/설계)</p>
</li>
</ul>
<pre><code>- 요청받은거 미리 기록해두고, 모니터링 시에 기록내용으로 실제 컨테이너를 비교하여 달라졌을 경우 상태를 맞춤.
- Desired State
    - 현재 상태 == 원하는 상태
    - **(LOOP) Observer 상태 → Diff 차이→ Act 조치**
- Scheduler
    - 컨테이너 체크
- Controller 역할 부여
    - 상태 체크
    - e.g. Replication Controller(복제set 체크), Endpoint Controller(서비스, 로드밸런싱 체크), Namespace Controller, Custom Controller, ML Controller, CI/CD Controller..

- Master 체크, 실행 부분
    - api server 중간 교통정리
        - 조회 요청
        - 상태를 바꾸거나 조회
        - etcd와 유일하게 통신하는 모듈
        - REST API형태로 제공
        - 권한을 체크하여 적절한 권한이 없을 경우 요청을 차단
        - 관리자 요청 뿐 아니라 다양한 내부 모듈과 통신
        - 수평으로 확장되도록 디자인
    - 상태 저장 조회는 etcd
        - 모든 상태와 데이터를 저장
        - 분산 시스템으로 구성하여 안전성을 높임(고가용성)
        - 가볍고 빠르면서 정확하게 설계(일관성)
        - Key(directory)-Value 형태로 데이터 저장
        - TTL(time to live), watch와 같은 부가 기능 제공
        - 백업은 필수
    - Scheduler 어떤 노드에 어떤 컨테이너를?
        - 새로 생성된 Pod을 감지하고 실행할 노드를 선택
        - 노드의 현재 상태와 Pod의 요구사항을 체크
            - 노드에 라벨을 부여 e.g. a-zone, b-zone
    - Controller
        - 논리적으로 다양한 컨트롤러가 존재
        - 끊임없이 상태체크, 원하는 상태 유지
        - 복잡성 낮추기 위해 단일 프로세스로 실행
    - 조회흐름
        1. 정보조회 Controller가 API Server에 물어봄
        2. API SERVER가 정보 조회 권한 체크 
        3. etcd에 정보조회를 해서 알려줌

        1. etcd에는 원하는 상태 변경

        2. 컨트롤러에 원하는 상태 변경

        3. 컨트롤러는 원하는 상태로 리소스 변경

        4. 변경사항을 api server에 전달

        5. 정보 갱신 권한 체크

        6. etcd에 정보갱신

        → 수많은 스케줄러와 컨트롤러가 etcd와 직접통신이 아닌 api server와 통신하여 전달

- Node는 실제로 실행되는 부분
    - Proxy
        - 네트워크 프록시와 부하 분산 역할
        - 성능상 이슈로 별도 프록시 프로그램 대신 iptables or IPVS 사용(설정만 관리)
    - Kubelet 컨테이너 관리 확실하게 pod이라는 것으로 감싸서
        - 각 노드에서 실행
        - Pod을 실행/중지하고 상태체크
        - CRI(Container Runtime Interface)
            - docker
            - Containerd
            - CRI-O

- 쿠버네티스 흐름
    1. api server에 pod 요청
    2. etcd에 생성요청
    3. controller가 새 pod 확인
    4. 실제 Pod 할당 요청을 다시 함
    5. api서버는 etcd에 pod 할당 요청
    6. 스케줄러는 새 pod 할당 확인
    7. 특정 노드에 pod 할당
    8. api서버는 다시 받아서 etcd에 이 pod을 특정 노드에 할당 / 미실행
    9. Kubelet 큐블릿이 미실행 pod 확인
    10. pod 생성
    11. api server가 pod 생성 업데이트 etcd pot 실행중</code></pre><ul>
<li><p>쿠버네티스 <strong>오브젝트</strong></p>
<ul>
<li>Pod : 가장 작은 배포 단위<ul>
<li>컨테이너를 pod으로 감싸서 배포</li>
<li>전체 클러스터에서 고유한 IP를 할당  -내부적으로 통신 가능</li>
<li>여러개의 컨테이너가 하나의 Pod에 속할 수 있음</li>
</ul>
</li>
<li>ReplicaSet : 여러개의 Pod을 관리<ul>
<li>replicas = 3&gt;4</li>
<li>새로운 Pod은 Template을 참고하여 생성</li>
<li>신규 Pod을 생성하거나 기존 Pod을 제거하여 원하는 수(Replicas)를 유지</li>
</ul>
</li>
<li>Deployment : 배포 버전을 관리. ReplicaSet을 감싼 애<ul>
<li>replicaset 자체를 활용해서 버전 관리</li>
</ul>
</li>
<li>다양한 Workload<ul>
<li>Daemon set : 모든 노드에 꼭 하나씩만 떠있길 원하는 pod을 생성하기 원할 때, 로그 수집 용도 등</li>
<li>Stateful sets: 같은 볼륨 재활용 등</li>
<li>JOB : 한번 실행하고 죽는 pod</li>
</ul>
</li>
<li>Service<ul>
<li>ClusterIP<ul>
<li>클러스터 내부에서 사용하는 프록시</li>
<li>클러스터 내부에서 서비스 연결은 DNS를 이용</li>
</ul>
</li>
<li>NodePort<ul>
<li>노드(host)에 노출되어 외부에서 접근 가능한 서비스</li>
<li>모든 노드에 동일한 포트로 생성</li>
</ul>
</li>
<li>LoadBalancer<ul>
<li>하나의 IP주소를 외부에 노출</li>
</ul>
</li>
</ul>
</li>
<li>Ingress<ul>
<li>도메인 또는 경로별 라우팅<ul>
<li>Nginx, HAProxy, ALB, …</li>
</ul>
</li>
</ul>
</li>
<li>일반적인 구성 : pod을 띄우는 경우는 잘 없음. Deployment 생성 시 replicaSet이 자동으로 생성되고, replicaSet이 pod을 자동으로 생성함. 외부로 노출하기위해 service를 붙이고, ingress를 붙여서 loadBalancer가 자동으로 붙음.</li>
<li>실제 클라이언트는 저 도메인으로 접속하면 loadBalancer를 거쳐서 NodePort를 거쳐서 clusterIp를 거쳐서 pod으로 연결됨.</li>
<li>그 외 기본 오브젝트<ul>
<li>Volume - Storage(EBS, NFS, …)</li>
<li>Namespace - 논리적인 리소스 구분</li>
<li>ConfigMap/Secret - 설정</li>
<li>ServiceAccount - 권한 게정</li>
<li>Role/ClusterRole - 권한 설정(get, list, watch, create, …)</li>
</ul>
</li>
</ul>
</li>
<li><p>쿠버네티스 API 호출</p>
<ul>
<li>YAML<ul>
<li>key-value 형식으로 사용 , 명세를 작성</li>
</ul>
</li>
<li>API 호출 : 원하는 상태(desired state)를 다양한 오브젝트(object)로 정의(spec)하고 API서버에 YAML 형식으로 전달</li>
</ul>
</li>
</ul>
<p>#2 쿠버네티스 실습 준비</p>
<p><a href="https://subicura.com/k8s/prepare/yaml.html">YAML 문법</a></p>
<ul>
<li><p>YAML 야믈 문법  ←JSON과 비슷</p>
<ul>
<li><p>들여쓰기(indent) : 들여쓰기는 기본적으로 2칸(추천) 또는 4칸 지원</p>
</li>
<li><p>데이터 정의(map) : 데이터는 key : value 형식으로 정의</p>
<ul>
<li>key와 value 사이에는 반드시 빈칸이 필요</li>
</ul>
</li>
<li><p>배열 정의(array) : 배열은 - 로 표시</p>
</li>
<li><p>주석(comment) #</p>
</li>
<li><p>참/거짓 : ture, false 외에 yes, no 지원</p>
</li>
<li><p>숫자 : 정수 또는 실수를 따옴표(”) 없이 사용하면 숫자로 인식</p>
</li>
<li><p>줄바꿈(newline)</p>
<ul>
<li>“|” 마지막 줄바꿈이 포함</li>
<li>“|-” 마지막 줄바꿈을 제외</li>
<li>“&gt;” 중간에 들어간 빈줄은 제외</li>
</ul>
</li>
<li><p>문자열 따옴표 “:”가 들어간 경우는 반드시 따옴표가 필요 “c:” or ‘c:’</p>
</li>
<li><p>사이트 추천: json2yaml.com , yamllint.com</p>
<pre><code class="language-yaml">#comment
api: v1  # comment
kind: Pod
metadata:
name: echo
labels:
  type: app
skills:
  - docker
  - kubernetes
newlines_sample: |-
                      number one line

                      second line

                      last line</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="2-쿠버네티스-설치-및-실습">#2 쿠버네티스 설치 및 실습</h2>
<p>20230516</p>
<h3 id="설치">설치</h3>
<p>개발vs운영</p>
<p>쿠버네티스를 운영환경에 설치하기 위해선 최소 3대의 마스터 서버와 컨테이너 배포를 위한 n개의 노드서버가 필요함.</p>
<p>개발환경에서는 마스터와 노드가 하나에 있고 설치가 쉬운 docker, minikube, kind, K3S .. </p>
<p>우리는 미니쿠베로 실습</p>
<p>##minikube 무료, 간편</p>
<p>미니쿠베와 쿠버네티스의 차이</p>
<p>서버가 여러개일때 자동으로 스케줄링 되고, 로드밸런서나 persistent Local Storage를 테스트하기 어렵다. </p>
<p>Mac OS에서 미니쿠베</p>
<pre><code>    #홈브루로 미니쿠베 설치
    brew install minikube

    #버전확인
    minikube version

    #가상머신 시작
    minikube start --driver=hyperkit

    😄  Darwin 13.3.1 (arm64) 의 minikube v1.30.1
    ✨  유저 환경 설정 정보에 기반하여 hyperkit 드라이버를 사용하는 중

    ❌  Exiting due to DRV_UNSUPPORTED_OS: The driver 'hyperkit' is not supported on darwin/arm64
</code></pre><p>해결방법: docker <a href="https://docs.docker.com/desktop/install/mac-install/">설치</a></p>
<pre><code>    jMacui-iMac:~ ijaehui$ minikube start --driver=docker 
    😄  Darwin 13.3.1 (arm64) 의 minikube v1.30.1
    ✨  유저 환경 설정 정보에 기반하여 docker 드라이버를 사용하는 중
    📌  Using Docker Desktop driver with root privileges
    👍  minikube 클러스터의 minikube 컨트롤 플레인 노드를 시작하는 중
    🚜  베이스 이미지를 다운받는 중 ...
    💾  쿠버네티스 v1.26.3 을 다운로드 중 ...
        &gt; preloaded-images-k8s-v18-v1...:  330.52 MiB / 330.52 MiB  100.00% 5.84 Mi
        &gt; gcr.io/k8s-minikube/kicbase...:  336.39 MiB / 336.39 MiB  100.00% 4.38 Mi
    🔥  Creating docker container (CPUs=2, Memory=4000MB) ...
    ❗  This container is having trouble accessing https://registry.k8s.io
    💡  To pull new external images, you may need to configure a proxy: https://minikube.sigs.k8s.io/docs/reference/networking/proxy/
    🐳  쿠버네티스 v1.26.3 을 Docker 23.0.2 런타임으로 설치하는 중
        ▪ 인증서 및 키를 생성하는 중 ...
        ▪ 컨트롤 플레인이 부팅...
        ▪ RBAC 규칙을 구성하는 중 ...
    🔗  Configuring bridge CNI (Container Networking Interface) ...
        ▪ Using image gcr.io/k8s-minikube/storage-provisioner:v5
    🔎  Kubernetes 구성 요소를 확인...
    🌟  애드온 활성화 : storage-provisioner, default-storageclass
    🏄  끝났습니다! kubectl이 "minikube" 클러스터와 "default" 네임스페이스를 기본적으로 사용하도록 구성되었습니다.</code></pre><p>상태확인</p>
<pre><code>    jMacui-iMac:~ ijaehui$ minikube status
    minikube
    type: Control Plane
    host: Running
    kubelet: Running
    apiserver: Running
    kubeconfig: Configured</code></pre><p>사용안할 땐 중지</p>
<pre><code>    jMacui-iMac:~ ijaehui$ minikube stop
    ✋  "minikube" 노드를 중지하는 중 ...
    🛑  "minikube"를 SSH로 전원을 끕니다 ...
    🛑  1개의 노드가 중지되었습니다.</code></pre><p>가상머신 접속</p>
<pre><code>&gt;minikube ssh

minikube가 etcd 등 알아서 다 해주네 

kubectl 큐브컨트롤 설치 

kubectl은 쿠버네티스 CLI 도구. 쿠버네티스 클러스터에 명령어를 전달하는 가장 흔한 방법

클라우드 상의 가상머신 k3s

한달에 $20, 하루에 1000원 이하의 비용</code></pre><h3 id="쿠버네티스-실습">쿠버네티스 실습</h3>
<pre><code>    jMacui-iMac:index ijaehui$ docker-compose down
    [+] Running 3/3
     ✔ Container index-mysql-1      Removed                                                                                            0.5s 
     ✔ Container index-wordpress-1  Removed                                                                                            1.2s 
     ✔ Network index_default        Removed                                                                                            0.1s 
    jMacui-iMac:index ijaehui$ vi wordpress-k8s.yml
    jMacui-iMac:index ijaehui$ kubectl apply -f wordpress-k8s.yml
    deployment.apps/wordpress-mysql created
    service/wordpress-mysql created
    deployment.apps/wordpress created
    service/wordpress created
    jMacui-iMac:index ijaehui$ kubectl get all
    NAME                                   READY   STATUS              RESTARTS   AGE
    pod/wordpress-bd4df79df-4c9wn          1/1     Running             0          39s
    pod/wordpress-mysql-6b9c6b459d-5wpg5   0/1     ContainerCreating   0          39s

    NAME                      TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)        AGE
    service/kubernetes        ClusterIP   10.96.0.1       &lt;none&gt;        443/TCP        34m
    service/wordpress         NodePort    10.102.94.125   &lt;none&gt;        80:**31346**/TCP   39s
    service/wordpress-mysql   ClusterIP   10.109.245.99   &lt;none&gt;        3306/TCP       39s

    NAME                              READY   UP-TO-DATE   AVAILABLE   AGE
    deployment.apps/wordpress         1/1     1            1           39s
    deployment.apps/wordpress-mysql   0/1     1            0           39s

    NAME                                         DESIRED   CURRENT   READY   AGE
    replicaset.apps/wordpress-bd4df79df          1         1         1       39s
    replicaset.apps/wordpress-mysql-6b9c6b459d   1         1         0       39s</code></pre><h4 id="docker-사용으로-포트-접속-안될-때">docker 사용으로 포트 접속 안될 때</h4>
<pre><code>[**Docker Desktop (opens new window)**](https://www.docker.com/products/docker-desktop)이 설치되어 있으면 minikube가 기본으로 `docker` driver를 사용합니다. docker 드라이브러를 사용할 경우 서비스 노출 방법입니다.

샘플로 테스트한 wordpress의 쿠버네티스의 노출 포트는 31428이지만 접근하기 위해서는 `minikube service`명령어를 입력하고 프록시를 통해 접속해야 합니다.

`# 쿠버네티스 서비스 이름이 wordpress라면..
minikube service wordpress`</code></pre><pre><code class="language-jsx">    jMacui-iMac:index ijaehui$ minikube service wordpress
    |-----------|-----------|-------------|---------------------------|
    | NAMESPACE |   NAME    | TARGET PORT |            URL            |
    |-----------|-----------|-------------|---------------------------|
    | default   | wordpress |          80 | http://192.168.49.2:30825 |
    |-----------|-----------|-------------|---------------------------|
    🏃  wordpress 서비스의 터널을 시작하는 중
    |-----------|-----------|-------------|------------------------|
    | NAMESPACE |   NAME    | TARGET PORT |          URL           |
    |-----------|-----------|-------------|------------------------|
    | default   | wordpress |             | http://127.0.0.1:57038 |
    |-----------|-----------|-------------|------------------------|
    🎉  Opening service default/wordpress in default browser...
    ❗  Because you are using a Docker driver on darwin, the terminal needs to be open to run it.</code></pre>
<h3 id="기본-명령어">기본 명령어</h3>
<pre><code>- 쿠버네티스는 GUI가 없나요? 있다. Lens 라는 프로그램

실제 공부할땐 적합 No. kubectl로 한땀한땀 입력해보기

| 명령어 | 설명 |
| --- | --- |
| apply | 원하는 상태를 적용. 보통 -f 옵션으로 파일과 함께 사용 |
| get | 리소스 목록을 보여줌 |
| describe | 리소스의 상태를 자세하게 보여줌 |
| delete | 리소스 제거 |
| logs | 컨테이너의 로그를 봄 |
| exec | 컨테이너에 명령어를 전달. 컨테이너에 접근할 때 주로 사용 |
| config | kubectl 설정을 관리함 |
- alias 로 편하게 줄여쓰기

```
# alias 설정
alias k='kubectl'

# shell 설정 추가
echo "alias k='kubectl'" &gt;&gt; ~/.bashrc
source ~/.bashrc
```</code></pre><h3 id="상태-설정하기-apply">상태 설정하기 (apply)</h3>
<p>kubectl apply -f [파일명 또는 URL]</p>
<p>특이한 점은 파일명뿐 아니라 URL도 입력이 가능. 실제로 많은 예제가 URL을 제공</p>
<p>여기서는 워드프레스를 다시 배포</p>
<pre><code># 다시 한번 워드프레스 배포하기 (URL로!)
kubectl apply -f https://subicura.com/k8s/code/guide/index/wordpress-k8s.yml</code></pre><h3 id="리소스-목록보기-get">리소스 목록보기 (get)</h3>
<p>kubectl get [TYPE]</p>
<pre><code># Pod 조회
kubectl get pod

# 줄임말(Shortname)과 복수형 사용가능
kubectl get pods
kubectl get po

# 여러 TYPE 입력
kubectl get pod,service
# 줄임말 다중 조회
kubectl get po,svc

# 가장 흔히 보이는 리소스 pod ,service, deployment, replicaset ,jop 을 보여줌
kubectl get all

# 결과 포멧 변경
kubectl get pod -o wide   &lt;- ip, node 등 추가 정보 조회가능
kubectl get pod -o yaml   &lt;- 실제 상태를 거의 다 볼 수 있음
kubectl get pod -o json

# Label 조회
kubectl get pod --show-labels</code></pre><h3 id="리소스-상세-상태보기-describe">리소스 상세 상태보기 (describe)</h3>
<p>kubectl describe [TYPE]/[NAME] 또는 [TYPE] [NAME]</p>
<pre><code># Pod 조회로 이름 검색
kubectl get pod

# 조회한 이름으로 상세 확인
kubectl describe pod/wordpress-89dd89b6b-7rc7x  # 환경마다 이름이 다릅니다.</code></pre><h3 id="리소스-제거delete">리소스 제거(delete)</h3>
<pre><code>#Pod 조회로 이름 검색
kubectl get pod

# 조회한 Pod 제거
kubectl delete pod/wordpress-89dd89b6b-7rc7x</code></pre><h3 id="로그logs">로그(logs)</h3>
<blockquote>
<p>k logs wordpress-89dd89b6b-t8t8p</p>
</blockquote>
<h3 id="컨테이너-명령어-전달-exec">컨테이너 명령어 전달 (exec)</h3>
<pre><code>kubectl exec -it wordpress-89dd89b6b-t8t8p -- bash</code></pre><h3 id="설정-관리config">설정 관리(config)</h3>
<pre><code># 현재 컨텍스트 확인
kubectl config current-context

# 컨텍스트 설정
kubectl config use-context minikube</code></pre><h3 id="그외">그외</h3>
<pre><code># 전체 오브젝트 종류 확인
kubectl api-resources

# 특정 오브젝트 설명 보기
kubectl explain pod</code></pre><h3 id="워드프레스-리소스-제거">워드프레스 리소스 제거</h3>
<p>kubectl delete -f wordpress-k8s.yml</p>
<h1 id="pod">Pod</h1>
<p>pod은 쿠버네티스에서 관리하는 가장 작은 배포단위</p>
<p>쿠버네티스에서 어떤 것을 배포할 때 가장 작은 것</p>
<p>컨테이너를 만들긴 하지만 pod을 통해서 컨테이너를 관리함. pod을 배포, pod 안에 컨테이너가 존재.</p>
<p>pod은 한개 또는 여러개의 컨테이너를 포함함</p>
<pre><code># Pod 만들기
kubectl run echo --image ghcr.io/subicura/echo:v1

pod/echo created

# Pod 목록 조회
kubectl get pod

# 단일 Pod 상세 확인
kubectl describe pod/echo

# Pod 삭제
kubectl delete pod/echo</code></pre><h3 id="pod-생성과정">pod 생성과정</h3>
<p>: 1.Scheduler가 할당되지 않은 pod 감시 2.Scheduler가  pod을 노드에 할당 </p>
<ol>
<li>kubelete이 노드에 할당된 pod 감시 4. 컨테이너 생성 5. api server에 pod상태 전달</li>
</ol>
<p>리소스 배포 시 pod을 YAML 파일로 정의함</p>
<pre><code>jMacui-iMac:index ijaehui$ **vi echo-pod.yml**
jMacui-iMac:index ijaehui$ k apply -f echo-pod.yml
pod/echo created
jMacui-iMac:index ijaehui$ **k get po**
NAME   READY   STATUS    RESTARTS   AGE
echo   1/1     Running   0          4s
</code></pre><h3 id="컨테이너-상태-모니터링">컨테이너 상태 모니터링</h3>
<ul>
<li><p>livenessProbe : 컨테이너가 정상동작하는지 체크하고 정상동작하지 않는다면 <strong>컨테이너를 재시작</strong>하여 문제해결</p>
</li>
<li><p>readinessProbe : 컨테이너가 준비되었는지 체크하고 정상적으로 준비되지 않았다면 Pod으로 들어오는 요청을 제외함. livenessProbe와 차이점은 <strong>문제가 있어도 Pod을 재시작하지 않고 요청만 제외</strong>한다는 점.</p>
</li>
<li><p><strong>livenessProbe + readinessProbe</strong></p>
<p>  보통 <code>livenessProbe</code>와 <code>readinessProbe</code>를 같이 적용합</p>
</li>
</ul>
<h3 id="다중-컨테이너">다중 컨테이너</h3>
<p>대부분 <code>1 Pod = 1 컨테이너</code>지만 여러 개의 컨테이너를 가진 경우도 꽤 흔함</p>
<p>하나의 Pod에 속한 컨테이너는 서로 네트워크를 <strong>localhost로 공유하고 동일한 디렉토리를 공유 가능.</strong></p>
<p>요청횟수를 redis에 저장하는 간단한 웹 애플리케이션을 다중 컨테이너로 생성</p>
<p><strong>환경변수 설정</strong>환경변수(env) 정의. env는 <code>name</code>과 <code>value</code>를 별도로 정의함</p>
<pre><code># 다중 컨테이너 

jMacui-iMac:pod ijaehui$ k exec -it counter -c app -- sh
/app # ls
Dockerfile         app.js             package-lock.json
README.md          node_modules       package.json
/app # apk add curl busybox-extras
fetch https://dl-cdn.alpinelinux.org/alpine/v3.15/main/aarch64/APKINDEX.tar.gz
fetch https://dl-cdn.alpinelinux.org/alpine/v3.15/community/aarch64/APKINDEX.tar.gz
OK: 10 MiB in 23 packages
/app # curl localhost:3000
1
/app # curl localhost:3000
2
/app # telnet locahost 6379
telnet: bad address 'locahost'
/app # telnet localhost 6379
Connected to localhost
dbsize
:1
KEYS *
*1
$5
count
GET count
$1
2
quit
+OK
Connection closed by foreign host
/app #

# 디렉토리 내부 pod 삭제 

jMacui-iMac:pod ijaehui$ k delete -f ./
pod "counter" deleted
pod "echo-lp" deleted
pod "echo-health" deleted
pod "echo-rp" deleted</code></pre><p>실습</p>
<p><strong>실습1. 다음 조건을 만족하는 Pod을 만드세요.</strong></p>
<table>
<thead>
<tr>
<th>키</th>
<th>값</th>
</tr>
</thead>
<tbody><tr>
<td><code>Pod 이름</code></td>
<td>mongodb</td>
</tr>
<tr>
<td><code>Pod Label</code></td>
<td>app: mongo</td>
</tr>
<tr>
<td><code>Container 이름</code></td>
<td>mongodb</td>
</tr>
<tr>
<td><code>Container 이미지</code></td>
<td>mongo:4</td>
</tr>
</tbody></table>
<pre><code>apiVersion: v1
kind: Pod
metadata:
  name: mongodb
  labels:
        app: mongo
spec:
    containers:
      - name: mongodb
            image: mongo:4</code></pre><p>ok </p>
<p><strong>실습2. 다음 조건을 만족하는 Pod을 만드세요.</strong></p>
<table>
<thead>
<tr>
<th>키</th>
<th>값</th>
</tr>
</thead>
<tbody><tr>
<td><code>Pod 이름</code></td>
<td>mariadb</td>
</tr>
<tr>
<td><code>Pod Label</code></td>
<td>app: mariadb</td>
</tr>
<tr>
<td><code>Container 이름</code></td>
<td>mariadb</td>
</tr>
<tr>
<td><code>Container 이미지</code></td>
<td>mariadb:10.7</td>
</tr>
<tr>
<td><code>Container 환경변수</code></td>
<td>MYSQL_ROOT_PASSWORD: 123456</td>
</tr>
</tbody></table>
<pre><code>apiVersion: v1
kind: Pod
metadata:
    name: mariadb
    labels:
        app: mariadb
spec:
    containers:
        - name: mariadb
            image: mariadb:10.7
            env:
                - name: MYSQL_ROOT_PASSWORD
                    value: '123456'</code></pre><h2 id="replicaset">ReplicaSet</h2>
<p>ReplicaSet은 원하는 개수의 Pod을 유지하는 역할.</p>
<p>label을 이용하여 Pod을 체크하기 때문에 label이 겹치지 않게 정의해야함</p>
<p>실전에서 ReplicaSet을 단독으로 쓰는 경우는 거의 없음. Deployment가 ReplicaSet을 이용하고 주로 Deployment를 사용함.</p>
<ul>
<li>guide/replicaset/echo-rs.yml</li>
</ul>
<pre><code>
apiVersion: apps/v1
kind: ReplicaSet
metadata:
  name: echo-rs
spec:
  replicas: 1
  selector:
    matchLabels:
      app: echo
      tier: app
  template:
    metadata:
      labels:
        app: echo
        tier: app
    spec:
      containers:
        - name: echo
          image: ghcr.io/subicura/echo:v1</code></pre><ul>
<li>labels이 중요함</li>
</ul>
<pre><code># 생성된 pod의 label 확인
k get po --show-labels

# 실행결과
NAME            READY   STATUS    RESTARTS        AGE     LABELS
echo-rs-rr47s   1/1     Running   0               16m     **app=echo,tier=app**

# 임의로 label 제거
# app- 를 지정하면 app label을 제거
kubectl label pod/echo-rs-rr47s app-

pod/echo-rs-rr47s unlabeled

jMacui-iMac:pod ijaehui$ k get po --show-labels
NAME            READY   STATUS    RESTARTS        AGE     LABELS
**echo-rs-ksxkw   1/1     Running   0               16s     app=echo,tier=app**
**echo-rs-rr47s   1/1     Running   0               18m     tier=app**

#다시 app 추가
jMacui-iMac:pod ijaehui$ k label po/echo-rs-rr47s app=echo
pod/echo-rs-rr47s labeled

# 조회하면  **echo-rs-ksxkw** 을 죽임
jMacui-iMac:pod ijaehui$ k get po --show-labels
NAME            READY   STATUS    RESTARTS        AGE     LABELS
**echo-rs-rr47s   1/1     Running   0               20m     app=echo,tier=app**
</code></pre><ul>
<li><p>ReplicaSet 작동 로직</p>
<ol>
<li>ReplicaSet 조건 체크 </li>
<li>조건을 만족하기 위해 Pod 생성, 제거</li>
<li>할당되지 않은 pod 감시</li>
<li>Pod을 노드에 할당</li>
</ol>
</li>
<li><p>ReplicaSet 개수 수정 1 → 4</p>
<pre><code>  vi echo-rs.yml

  k apply -f echo-rs.yml
  replicaset.apps/echo-rs configured

  k get po
  NAME            READY   STATUS    RESTARTS        AGE
  echo            1/1     Running   3 (2d15h ago)   3d17h
  echo-rs-9h6m4   1/1     Running   0               6s
  echo-rs-b7hrp   1/1     Running   0               6s
  echo-rs-jkmts   1/1     Running   0               6s
  echo-rs-rr47s   1/1     Running   0               25m</code></pre></li>
</ul>
<h2 id="deployment">Deployment</h2>
<ul>
<li>echo-deployment.yml</li>
</ul>
<pre><code>apiVersion: apps/v1
**kind: Deployment**
metadata:
  **name: echo-deploy**
spec:
  replicas: 4
  selector:
    matchLabels:
      app: echo
      tier: app
  template:
    metadata:
      labels:
        app: echo
        tier: app
    spec:
      containers:
        - name: echo
          ~~image: ghcr.io/subicura/echo:v1~~
          image: ghcr.io/subicura/echo:v2</code></pre><p>Deployment는 새로운 이미지로 업데이트하기 위해 ReplicaSet을 이용</p>
<p>버전을 업데이트하면 새로운 ReplicaSet을 생성하고 해당 ReplicaSet이 새로운 버전의 Pod을 생성</p>
<p>deployment 버전관리</p>
<p>ReplicaSet(v1) : replicaSet = 4 , ReplicaSet(v2) : replicaSet = 0</p>
<p>ReplicaSet(v1) : replicaSet = 3 , ReplicaSet(v2) : replicaSet = 1</p>
<p>ReplicaSet(v1) : replicaSet = 2 , ReplicaSet(v2) : replicaSet = 2</p>
<p>ReplicaSet(v1) : replicaSet = 1 , ReplicaSet(v2) : replicaSet = 3</p>
<p>ReplicaSet(v1) : replicaSet = 0 , ReplicaSet(v2) : replicaSet = 4</p>
<pre><code># deployment 가 ReplicaSet을 조정
jMacui-iMac:pod ijaehui$ k describe deploy/echo-deploy
Name:                   echo-deploy
Namespace:              default
CreationTimestamp:      Mon, 22 May 2023 10:48:11 +0900
Labels:                 &lt;none&gt;
Annotations:            deployment.kubernetes.io/revision: 2
Selector:               app=echo,tier=app
Replicas:               4 desired | 4 updated | 4 total | 4 available | 0 unavailable
StrategyType:           RollingUpdate
MinReadySeconds:        0
RollingUpdateStrategy:  25% max unavailable, 25% max surge
Pod Template:
  Labels:  app=echo
           tier=app
  Containers:
   echo:
    Image:        ghcr.io/subicura/echo:v2
    Port:         &lt;none&gt;
    Host Port:    &lt;none&gt;
    Environment:  &lt;none&gt;
    Mounts:       &lt;none&gt;
  Volumes:        &lt;none&gt;
Conditions:
  Type           Status  Reason
  ----           ------  ------
  Available      True    MinimumReplicasAvailable
  Progressing    True    NewReplicaSetAvailable
OldReplicaSets:  echo-deploy-86b9d46884 (0/0 replicas created)
NewReplicaSet:   echo-deploy-7b549bc55c (4/4 replicas created)
Events:
  Type    Reason             Age    From                   Message
  ----    ------             ----   ----                   -------
  Normal  ScalingReplicaSet  9m30s  deployment-controller  Scaled up replica set echo-deploy-86b9d46884 to 4
  Normal  ScalingReplicaSet  4m53s  deployment-controller  Scaled up replica set echo-deploy-7b549bc55c to 1
  Normal  ScalingReplicaSet  4m53s  deployment-controller  Scaled down replica set echo-deploy-86b9d46884 to 3 from 4
  Normal  ScalingReplicaSet  4m53s  deployment-controller  Scaled up replica set echo-deploy-7b549bc55c to 2 from 1
  Normal  ScalingReplicaSet  4m11s  deployment-controller  Scaled down replica set echo-deploy-86b9d46884 to 2 from 3
  Normal  ScalingReplicaSet  4m11s  deployment-controller  Scaled up replica set echo-deploy-7b549bc55c to 3 from 2
  Normal  ScalingReplicaSet  4m10s  deployment-controller  Scaled down replica set echo-deploy-86b9d46884 to 1 from 2
  Normal  ScalingReplicaSet  4m10s  deployment-controller  Scaled up replica set echo-deploy-7b549bc55c to 4 from 3
  Normal  ScalingReplicaSet  4m10s  deployment-controller  Scaled down replica set echo-deploy-86b9d46884 to 0 from 1</code></pre><ul>
<li>deployment 작동로직<ol>
<li>deployment 가 원하는 배포상태체크</li>
<li>조건에 맞는 ReplicaSet 생성</li>
<li>ReplicaSet 조건 체크</li>
<li>조건을 만족하기 위해 Pod 생성, 제거</li>
<li>Scheduler가 할당되지 않은 Pod 감시</li>
<li>Pod을 노드에 할당</li>
</ol>
</li>
</ul>
<h3 id="버전관리">버전관리</h3>
<ul>
<li>변경된 상태를 기록함</li>
</ul>
<pre><code># 히스토리 확인
kubectl rollout history deploy/echo-deploy

# revision 1 히스토리 상세 확인
kubectl rollout history deploy/echo-deploy --revision=1

# 바로 전으로 롤백
kubectl rollout undo deploy/echo-deploy

# 특정 버전으로 롤백
kubectl rollout undo deploy/echo-deploy --to-revision=2</code></pre><h3 id="배포-전략-설정">배포 전략 설정</h3>
<ul>
<li>다양한 방식의 배포 전략</li>
<li>echo-deployment.yml</li>
</ul>
<pre><code>apiVersion: apps/v1
kind: Deployment
metadata:
  name: echo-deploy-st
spec:
  replicas: 4
  selector:
    matchLabels:
      app: echo
      tier: app
  **minReadySeconds: 5
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 3
      maxUnavailable: 3**
  template:
    metadata:
      labels:
        app: echo
        tier: app
    spec:
      containers:
        - name: echo
          image: ghcr.io/subicura/echo:v1
          livenessProbe:
            httpGet:
              path: /
              port: 3000</code></pre><pre><code>jMacui-iMac:pod ijaehui$ vi echo-deployment.yml
jMacui-iMac:pod ijaehui$ k apply -f echo-deployment.yml
deployment.apps/echo-deploy configured
jMacui-iMac:pod ijaehui$ k get all
NAME                               READY   STATUS    RESTARTS        AGE
pod/echo                           1/1     Running   3 (2d18h ago)   3d19h
pod/echo-deploy-7b549bc55c-6g9jd   1/1     Running   0               11s
pod/echo-deploy-7b549bc55c-7dq5x   1/1     Running   0               11s
pod/echo-deploy-7b549bc55c-bkkp6   1/1     Running   0               11s
pod/echo-deploy-7b549bc55c-xmzwn   1/1     Running   0               11s

NAME                 TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE
service/kubernetes   ClusterIP   10.96.0.1    &lt;none&gt;        443/TCP   6d

NAME                          READY   UP-TO-DATE   AVAILABLE   AGE
deployment.apps/echo-deploy   4/4     4            4           76m

NAME                                     DESIRED   CURRENT   READY   AGE
replicaset.apps/echo-deploy-7b549bc55c   4         4         4       72m
replicaset.apps/echo-deploy-86b9d46884   0         0         0       76m
jMacui-iMac:pod ijaehui$ k get rs -w
NAME                     DESIRED   CURRENT   READY   AGE
echo-deploy-7b549bc55c   4         4         4       72m
echo-deploy-86b9d46884   0         0         0       77m
^CjMacui-iMac:pod ijaehui$ vi echo-deployment.yml
jMacui-iMac:pod ijaehui$ k apply -f echo-deployment.yml
deployment.apps/echo-deploy configured
jMacui-iMac:pod ijaehui$ k get rs -w
NAME                     DESIRED   CURRENT   READY   AGE
echo-deploy-7b549bc55c   1         1         1       73m
echo-deploy-86b9d46884   4         4         1       78m
echo-deploy-86b9d46884   4         4         2       78m
echo-deploy-86b9d46884   4         4         3       78m
echo-deploy-86b9d46884   4         4         4       78m
echo-deploy-86b9d46884   4         4         4       78m
echo-deploy-7b549bc55c   0         1         1       73m
echo-deploy-7b549bc55c   0         1         1       73m
echo-deploy-7b549bc55c   0         0         0       73m
^CjMacui-iMac:pod ijaehuivi echo-deployment.yml</code></pre><h2 id="deployment-문제">Deployment <strong>문제</strong></h2>
<p><strong>문제1. 다음 조건을 만족하는 Deployment를 만드세요.</strong></p>
<table>
<thead>
<tr>
<th>키</th>
<th>값</th>
</tr>
</thead>
<tbody><tr>
<td><code>Deployment 이름</code></td>
<td>nginx</td>
</tr>
<tr>
<td><code>Deployment Label</code></td>
<td>app: nginx</td>
</tr>
<tr>
<td><code>Deployment 복제수</code></td>
<td>3</td>
</tr>
<tr>
<td><code>Container 이름</code></td>
<td>nginx</td>
</tr>
<tr>
<td><code>Container 이미지</code></td>
<td>nginx:1.14.2</td>
</tr>
</tbody></table>
<p><strong>문제2. 복제개수를 5로 조정합니다</strong></p>
<p><strong>문제3. 이미지를 nginx:1.19.5로 변경합니다</strong></p>
<p><strong>답 작성.</strong></p>
<pre><code>apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx
spec:
  ~~replicas: 3~~
  replicas: 5
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
        - name: nginx
          ~~image: nginx:1.14.2~~
          image: nginx:1.19.5</code></pre><h2 id="service">Service</h2>
<p>Pod은 고유한 ip를 가지고 다른 Pod과 통신가능. 쉽게 사라지고 생성되는 특징때문에 직접 통신하는 방법은 권장하지 않음.</p>
<p>쿠버네티스틑 별도의 고정된 ip를 가진 서비스를 만들고 그 서비스를 통해 Pod에 접근하는 방식 사용</p>
<h3 id="serviceclusterip-만들기">Service(ClusterIP) 만들기</h3>
<p>ClusterIP는 클러스터 내부에 새로운 IP를 할당하고 여러 개의 Pod을 바라보는 로드밸런서 기능을 제공함.</p>
<p>서비스 이름을 내부 도메인 서버에 등록하여 Pod 간에 서비스 이름으로 통신할 수 있음.</p>
<p>ClusterIP 서비스의 설정</p>
<table>
<thead>
<tr>
<th>정의</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td><code>spec.ports.port</code></td>
<td>서비스가 생성할 Port</td>
</tr>
<tr>
<td><code>spec.ports.targetPort</code></td>
<td>서비스가 접근할 Pod의 Port (기본: port랑 동일)</td>
</tr>
<tr>
<td><code>spec.selector</code></td>
<td>서비스가 접근할 Pod의 label 조건</td>
</tr>
</tbody></table>
<pre><code>k apply -f counter-app.yml

# counter app 에 접근
k get po
k exec -it counter-&lt;xxxxx&gt; -- sh

# apk add curl busybox-extras #install talnet
# curl localhost:3000
# curl localhost:3000
#telnet redis 6379
  dbsize
  KEYS *
  GET count
  quit

jMacui-iMac:service ijaehui$ **k exec -it counter-587b8d775-lvdt7 -- sh**

/app # **apk add curl busybox-extras**
fetch https://dl-cdn.alpinelinux.org/alpine/v3.15/main/aarch64/APKINDEX.tar.gz
fetch https://dl-cdn.alpinelinux.org/alpine/v3.15/community/aarch64/APKINDEX.tar.gz
OK: 10 MiB in 23 packages

/app # **curl localhost:3000**
1
/app # **curl localhost:3000**
2
/app # **telnet redis 6379**
Connected to redis

**dbsize**
:1

**KEYS ***
*1
$5

**GET count**
$1
2
</code></pre><ul>
<li><p>서비스 동작 로직</p>
<ol>
<li>Endpoint Controller 가 Service 감시</li>
<li>Endpoint 생성</li>
<li>Kube-Proxy가 Endpoint 감시  kube-Proxy는 각 node에 설치되어 있음.  Endpoint 변경 시 iptables 설정</li>
<li>CoreDNS가 Service 감시. Domain Name Sevice</li>
</ol>
</li>
<li><p>Endpoint 쿠버네티스의 리소스 중 하나 ep</p>
</li>
</ul>
<pre><code>jMacui-iMac:service ijaehui$ k get endpoints
NAME         ENDPOINTS           AGE
kubernetes   192.168.49.2:8443   6d5h
redis        10.244.0.61:6379    63m
jMacui-iMac:service ijaehui$ k describe ep/redis
Name:         redis
Namespace:    default
Labels:       &lt;none&gt;
Annotations:  endpoints.kubernetes.io/last-change-trigger-time: 2023-05-22T06:54:22Z
Subsets:
  Addresses:          **10.244.0.61**
  NotReadyAddresses:  &lt;none&gt;
  Ports:
    Name     Port  Protocol
    ----     ----  --------
    &lt;unset&gt;  6379  TCP

Events:  &lt;none&gt;
jMacui-iMac:service ijaehui$ k get po
NAME                           READY   STATUS    RESTARTS        AGE
counter-587b8d775-lvdt7        1/1     Running   0               56m
echo                           1/1     Running   3 (2d22h ago)   4d
echo-deploy-86b9d46884-f2rtl   1/1     Running   0               4h52m
echo-deploy-86b9d46884-gl62c   1/1     Running   0               4h52m
echo-deploy-86b9d46884-w4879   1/1     Running   0               4h52m
echo-deploy-86b9d46884-w7rkh   1/1     Running   0               4h52m
redis-69cdf76f59-7f2nj         1/1     Running   0               64m
jMacui-iMac:service ijaehui$ k get po -o wide
NAME                           READY   STATUS    RESTARTS        AGE     IP            NODE       NOMINATED NODE   READINESS GATES
counter-587b8d775-lvdt7        1/1     Running   0               56m     10.244.0.62   minikube   &lt;none&gt;           &lt;none&gt;
echo                           1/1     Running   3 (2d22h ago)   4d      10.244.0.26   minikube   &lt;none&gt;           &lt;none&gt;
echo-deploy-86b9d46884-f2rtl   1/1     Running   0               4h52m   10.244.0.58   minikube   &lt;none&gt;           &lt;none&gt;
echo-deploy-86b9d46884-gl62c   1/1     Running   0               4h52m   10.244.0.59   minikube   &lt;none&gt;           &lt;none&gt;
echo-deploy-86b9d46884-w4879   1/1     Running   0               4h52m   10.244.0.60   minikube   &lt;none&gt;           &lt;none&gt;
echo-deploy-86b9d46884-w7rkh   1/1     Running   0               4h52m   10.244.0.57   minikube   &lt;none&gt;           &lt;none&gt;
redis-69cdf76f59-7f2nj         1/1     Running   0               64m     **10.244.0.61**   minikube   &lt;none&gt;           &lt;none&gt;
</code></pre><h3 id="servicenodeport-만들기">Service(NodePort) 만들기</h3>
<p>ClusterIP는 클러스터 내부에서만 접근가능. 실제론 밖에서 접속해야하므로, 밖에서 접속하는 방법 알아보기</p>
<p>클러스터 외부(노드)에서 접근할 수 있도록 NodePort 서비스 만들어보기</p>
<ul>
<li>클러스터 외부에서 접속</li>
</ul>
<pre><code>jMacui-iMac:service ijaehui$ cat counter-nodeport.yml
apiVersion: v1
kind: Service
metadata:
  name: counter-np
spec:
  type: NodePort
  ports:
    - port: 3000
      protocol: TCP
      nodePort: 31000
  selector:
    app: counter
    tier: app
jMacui-iMac:service ijaehui$ k apply -f counter-nodeport.yml
service/counter-np created
jMacui-iMac:service ijaehui$ k get svc
NAME         TYPE        CLUSTER-IP    EXTERNAL-IP   PORT(S)          AGE
counter-np   NodePort    10.98.5.200   &lt;none&gt;        3000:31000/TCP   5s
kubernetes   ClusterIP   10.96.0.1     &lt;none&gt;        443/TCP          6d5h
redis        ClusterIP   10.99.83.25   &lt;none&gt;        6379/TCP         68m
jMacui-iMac:service ijaehui$ minikube ip
192.168.49.2
jMacui-iMac:service ijaehui$ minikube service counter-np
|-----------|------------|-------------|---------------------------|
| NAMESPACE |    NAME    | TARGET PORT |            URL            |
|-----------|------------|-------------|---------------------------|
| default   | counter-np |        3000 | http://192.168.49.2:31000 |
|-----------|------------|-------------|---------------------------|
🏃  counter-np 서비스의 터널을 시작하는 중
|-----------|------------|-------------|------------------------|
| NAMESPACE |    NAME    | TARGET PORT |          URL           |
|-----------|------------|-------------|------------------------|
| default   | counter-np |             | **http://127.0.0.1:52771** |
|-----------|------------|-------------|------------------------|
🎉  Opening service default/counter-np in default browser...
❗  Because you are using a Docker driver on darwin, the terminal needs to be open to run it.</code></pre><ul>
<li>NodePort는 클러스터의 모든 노드에 포트를 오픈함. 여러개의 노드가 있다면 아무 노드로 접근해도 지정한 Pod으로 쏘옥 접근가능</li>
</ul>
<h3 id="serviceloadbalancer-만들기">Service(LoadBalancer) 만들기</h3>
<pre><code>jMacui-iMac:service ijaehui$ k apply -f counter-lb.yml
service/counter-lb created

jMacui-iMac:service ijaehui$ k get svc
NAME         TYPE           CLUSTER-IP       EXTERNAL-IP   PORT(S)           AGE
counter-lb   LoadBalancer   10.111.109.248   &lt;pending&gt;     30000:31910/TCP   10s
counter-np   NodePort       10.98.5.200      &lt;none&gt;        3000:31000/TCP    23h
kubernetes   ClusterIP      10.96.0.1        &lt;none&gt;        443/TCP           7d4h
redis        ClusterIP      10.99.83.25      &lt;none&gt;        6379/TCP          24h

jMacui-iMac:service ijaehui$ minikube addons enable metallb
❗  metallb is a 3rd party addon and is not maintained or verified by minikube maintainers, enable at your own risk.
❗  metallb does not currently have an associated maintainer.
▪ Using image [quay.io/metallb/speaker:v0.9.6](http://quay.io/metallb/speaker:v0.9.6)
▪ Using image [quay.io/metallb/controller:v0.9.6](http://quay.io/metallb/controller:v0.9.6)
🌟  'metallb' 애드온이 활성화되었습니다

jMacui-iMac:service ijaehui$ vi metallb-cm.yml

jMacui-iMac:service ijaehui$ k apply -f metallb-cm.yml
configmap/config configured

jMacui-iMac:service ijaehui$ k get svc
NAME         TYPE           CLUSTER-IP       EXTERNAL-IP    PORT(S)           AGE
counter-lb   LoadBalancer   10.111.109.248   **192.168.64.9**   30000:31910/TCP   3m
counter-np   NodePort       10.98.5.200      &lt;none&gt;         3000:31000/TCP    23h
kubernetes   ClusterIP      10.96.0.1        &lt;none&gt;         443/TCP           7d4h
redis        ClusterIP      10.99.83.25      &lt;none&gt;         6379/TCP          24h

jMacui-iMac:service ijaehui$ **minikube service counter-lb**
|-----------|------------|-------------|---------------------------|
| NAMESPACE |    NAME    | TARGET PORT |            URL            |
|-----------|------------|-------------|---------------------------|
| default   | counter-lb |       30000 | http://192.168.49.2:31910 |
|-----------|------------|-------------|---------------------------|
🏃  counter-lb 서비스의 터널을 시작하는 중
|-----------|------------|-------------|------------------------|
| NAMESPACE |    NAME    | TARGET PORT |          URL           |
|-----------|------------|-------------|------------------------|
| default   | counter-lb |             | **http://127.0.0.1:56844** |
|-----------|------------|-------------|------------------------|
🎉  Opening service default/counter-lb in default browser...
❗  Because you are using a Docker driver on darwin, the terminal needs to be open to run it.</code></pre><p>노드포트보다는 로드밸런서를 이용함. </p>
<p>로드밸런서 문제 : 하나의 서비스만 바라봄</p>
<p><strong>문제1. echo 서비스를 NodePort로 32000 포트로 오픈합니다.</strong></p>
<table>
<thead>
<tr>
<th>키</th>
<th>값</th>
</tr>
</thead>
<tbody><tr>
<td><code>Deployment 이름</code></td>
<td>echo</td>
</tr>
<tr>
<td><code>Deployment Label</code></td>
<td>app: echo</td>
</tr>
<tr>
<td><code>Deployment 복제수</code></td>
<td>3</td>
</tr>
<tr>
<td><code>Container 이름</code></td>
<td>echo</td>
</tr>
<tr>
<td><code>Container 이미지</code></td>
<td>ghcr.io/subicura/echo:v1</td>
</tr>
<tr>
<td><code>NodePort 이름</code></td>
<td>echo</td>
</tr>
<tr>
<td><code>NodePort Port</code></td>
<td>3000</td>
</tr>
<tr>
<td><code>NodePort NodePort</code></td>
<td>32000</td>
</tr>
</tbody></table>
<p><strong>답 작성.</strong></p>
<pre><code>apiVersion: apps/v1
kind: Deployment
metadata:
    name: echo
spec:
    replicas: 3
    selector:
        matchLabels:
            app: echo
    template:
        metadata:
            labels:
                app: echo
        spec:
            containers:
                - name: echo
                    image: ghcr.io/subicura/echo:v1
---
apiVersion: v1
kind: Service
metadata: 
    name: echo
spec:
    type: NodePort
    ports:
        - port: 3000
            protocol: TCP
            nodePort: 32000
    selector:
        app: echo
</code></pre><h2 id="워드프레스-배포">워드프레스 배포</h2>
<pre><code>jMacui-iMac:guide ijaehui$ k apply -f wordpress.yml &lt;- 배포
deployment.apps/wordpress-mysql created
service/wordpress-mysql unchanged
deployment.apps/wordpress unchanged
service/wordpress unchanged
jMacui-iMac:guide ijaehui$  k get all &lt;-확인
NAME                                  READY   STATUS    RESTARTS      AGE
pod/counter-587b8d775-lvdt7           1/1     Running   1 (23h ago)   24h
pod/echo                              1/1     Running   4 (23h ago)   5d
pod/echo-deploy-86b9d46884-f2rtl      1/1     Running   1 (23h ago)   28h
pod/echo-deploy-86b9d46884-gl62c      1/1     Running   1 (23h ago)   28h
pod/echo-deploy-86b9d46884-w4879      1/1     Running   1 (23h ago)   28h
pod/echo-deploy-86b9d46884-w7rkh      1/1     Running   1 (23h ago)   28h
pod/redis-69cdf76f59-7f2nj            1/1     Running   1 (23h ago)   24h
pod/wordpress-89dd89b6b-t74vm         1/1     Running   0             2m39s
pod/wordpress-mysql-87dbc78dc-ljdg9   1/1     Running   0             37s

NAME                      TYPE           CLUSTER-IP       EXTERNAL-IP    PORT(S)           AGE
service/counter-lb        LoadBalancer   10.111.109.248   192.168.64.9   30000:31910/TCP   41m
service/counter-np        NodePort       10.98.5.200      &lt;none&gt;         3000:31000/TCP    23h
service/kubernetes        ClusterIP      10.96.0.1        &lt;none&gt;         443/TCP           7d4h
service/redis             ClusterIP      10.99.83.25      &lt;none&gt;         6379/TCP          24h
service/wordpress         NodePort       10.107.167.147   &lt;none&gt;         80:30000/TCP      2m39s
service/wordpress-mysql   ClusterIP      10.109.107.143   &lt;none&gt;         3306/TCP          2m39s

NAME                              READY   UP-TO-DATE   AVAILABLE   AGE
deployment.apps/counter           1/1     1            1           24h
deployment.apps/echo-deploy       4/4     4            4           29h
deployment.apps/redis             1/1     1            1           24h
deployment.apps/wordpress         1/1     1            1           2m39s
deployment.apps/wordpress-mysql   1/1     1            1           37s

NAME                                        DESIRED   CURRENT   READY   AGE
replicaset.apps/counter-587b8d775           1         1         1       24h
replicaset.apps/echo-deploy-7b549bc55c      0         0         0       29h
replicaset.apps/echo-deploy-86b9d46884      4         4         4       29h
replicaset.apps/redis-69cdf76f59            1         1         1       24h
replicaset.apps/wordpress-89dd89b6b         1         1         1       2m39s
replicaset.apps/wordpress-mysql-87dbc78dc   1         1         1       37s
jMacui-iMac:guide ijaehui$ minikube service wordpress
|-----------|-----------|-------------|---------------------------|
| NAMESPACE |   NAME    | TARGET PORT |            URL            |
|-----------|-----------|-------------|---------------------------|
| default   | wordpress |          80 | http://192.168.49.2:30000 |
|-----------|-----------|-------------|---------------------------|
🏃  wordpress 서비스의 터널을 시작하는 중
|-----------|-----------|-------------|------------------------|
| NAMESPACE |   NAME    | TARGET PORT |          URL           |
|-----------|-----------|-------------|------------------------|
| default   | wordpress |             | http://127.0.0.1:51529 |
|-----------|-----------|-------------|------------------------|
🎉  Opening service default/wordpress in default browser...
❗  Because you are using a Docker driver on darwin, the terminal needs to be open to run it.</code></pre><p>총 deployment는 5개 필요 (vote, redis, worker, db, result)</p>
<p>nodePort Service는 2개 (투표한 화면, 결과보는 화면)</p>
<p>내부 오픈 서비스 ClusterIP Service 필요(redis, db)</p>
<p>worker는 port 접속 필요 x 스스로 redis에 접속해서 db에 전달하기 때문</p>
<h2 id="ingress">Ingress</h2>
<p>port는 하나만 오픈하고 도메인이나 path에 따라서 service를 분기해줌</p>
<h3 id="ingress-생성흐름">ingress 생성흐름</h3>
<ol>
<li>Ingress Controller 는 Ingress 변화를 체크</li>
<li>Ingress Controller 는 변경된 내용을 Nginx에 설정하고 프로세스 재시작</li>
</ol>
<p><strong>문제1. 다음 조건을 만족하는 Ingress를 만드세요.</strong></p>
<table>
<thead>
<tr>
<th>키</th>
<th>값</th>
</tr>
</thead>
<tbody><tr>
<td>Deployment 이름</td>
<td>nginx</td>
</tr>
<tr>
<td>Deployment Label</td>
<td>app: nginx</td>
</tr>
<tr>
<td>Deployment 복제수</td>
<td>3</td>
</tr>
<tr>
<td>Container 이름</td>
<td>nginx</td>
</tr>
<tr>
<td>Container 이미지</td>
<td>nginx:latest</td>
</tr>
<tr>
<td>Ingress 도메인</td>
<td>nginx.xxx.sslip.io</td>
</tr>
</tbody></table>
<p><strong>답 작성.</strong></p>
<pre><code>apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx
spec:
  replicaSet: 3
  selector:
    matchLables:
      app: nginx
    template:
      metadata:
        labels:
          app: nginx
      spec:
        containers:
          - name: nginx
            images: nginx:latest
---
apiVersion: v1
kind: Ingress
metadata:
  name: nginx-v1
spec:
  rules:
    - host: nginx.xxx.sslip.io   </code></pre><ul>
<li><p><strong>정답.</strong></p>
<pre><code>  apiVersion: networking.k8s.io/v1
  kind: Ingress
  metadata:
    name: nginx
  spec:
    rules:
      - host: nginx.192.168.64.5.sslip.io
        http:
          paths:
            - path: /
              pathType: Prefix
              backend:
                service:
                  name: nginx
                  port:
                    number: 80

  ---
  apiVersion: apps/v1
  kind: Deployment
  metadata:
    name: nginx
  spec:
    replicas: 3
    selector:
      matchLabels:
        app: nginx
    template:
      metadata:
        labels:
          app: nginx
      spec:
        containers:
          - name: echo
            image: nginx:latest

  ---
  apiVersion: v1
  kind: Service
  metadata:
    name: nginx
  spec:
    ports:
      - port: 80
        protocol: TCP
    selector:
      app: nginx</code></pre></li>
</ul>
<h2 id="volume-만들기">Volume 만들기</h2>
<h3 id="empty-dir">empty-dir</h3>
<p>한 pod 안에서 두개의 컨테이너가 디렉터리를 공유</p>
<h3 id="hostpath">hostpath</h3>
<p>한 pod 안에 있는 디렉터리가 외부 디렉터리와 연결 가능</p>
<p>쿠버네티스는 볼륨을 연결하는 방법을 추상</p>
<h2 id="configmap">ConfigMap</h2>
<p>특정환경변수부터 특정 설정 config까지 관리할 수 있음</p>
<p>파일을 통째로 ConfigMap으로 만든 다음 컨테이너에서 사용하는 방법을 알아봅니다.</p>
<p>`global:
  scrape_interval: 15s</p>
<p>scrape_configs:</p>
<ul>
<li>job_name: prometheus
metrics_path: /prometheus/metrics
static_configs:<ul>
<li>targets:<ul>
<li>localhost:9090`</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><a href="https://subicura.com/k8s/code/guide/configmap/config-file.yml"><strong>guide/configmap/config-file.yml (opens new window)</strong></a></p>
<p>먼저, ConfigMap을 만듭니다. <code>--from-file</code> 옵션을 이용하여 file을 설정으로 만듭니다.</p>
<p>`# ConfitMap 생성 configmap -&gt; cm
kubectl create cm my-config --from-file=config-file.yml</p>
<h1 id="confitmap-조회">ConfitMap 조회</h1>
<p>kubectl get cm</p>
<h1 id="configmap-내용-상세-조회">ConfigMap 내용 상세 조회</h1>
<p>kubectl describe cm/my-config`</p>
<p>생성한 ConfigMap을 <code>/etc/config</code> 디렉토리에 연결합니다.</p>
<h2 id="secret">Secret</h2>
<p>쿠버네티스에서 configMap은 비밀번호를 저장하기에는 적합하지 않음.</p>
<p>비밀번호, SSH 인증, TLS Secret 과 같은 보안정보를 관리하는 것은 Secret 을 이용.</p>
<p>실제로 데이터가 암호화되지는 않음.</p>
<p>모든 상태가 etcd에 평문으로 저장되기 때문에, 유출가능성이 있음.</p>
<p>secret을 직접 사용하지 않고, 하시코프에서 나온 벌트를 이용해서 암호화를 한다든가, 별도의 암호화 모듈을 사용하는 것을 추천</p>
<pre><code>jMacui-iMac:secret ijaehui$ vi username.txt
jMacui-iMac:secret ijaehui$ vi password.txt
jMacui-iMac:secret ijaehui$ k create secret generic db-user-pass --from-file=./username/txt --from-file=./password.txt
error: error reading ./username/txt: no such file or directory
jMacui-iMac:secret ijaehui$ k create secret generic db-user-pass --from-file=./username.txt --from-file=./password.txt
secret/db-user-pass created
jMacui-iMac:secret ijaehui$ k get secret
NAME           TYPE     DATA   AGE
db-user-pass   Opaque   2      5s
jMacui-iMac:secret ijaehui$ k describe secret/db-user-pass
Name:         db-user-pass
Namespace:    default
Labels:       &lt;none&gt;
Annotations:  &lt;none&gt;

Type:  Opaque

Data
====
password.txt:  9 bytes
username.txt:  6 bytes
jMacui-iMac:secret ijaehui$ k get secret/db-user-pass -o yaml &lt;- output 옵션 yaml
apiVersion: v1
data:
  password.txt: &lt;REDACTED&gt;  &lt;- base64 로 encoding
  username.txt: &lt;REDACTED&gt;
kind: Secret
metadata:
  creationTimestamp: "2023-05-24T01:41:02Z"
  name: db-user-pass
  namespace: default
  resourceVersion: "127241"
  uid: 6e47556c-10aa-44e7-ba56-7afbf88edec1
type: Opaque
jMacui-iMac:secret ijaehui$ **echo 'example_password' | base64 --decode**  &lt;- base64 로 decoding
</code></pre>